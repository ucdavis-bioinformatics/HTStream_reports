---
title: "Preproc mapping stats for Kol - Questa, ATAC Seq Canine"
output: html_notebook
---

```{r, echo=FALSE}
### SETTINGS ###
working_dir = "/share/biocore/joshi/projects/Kol_A_UCD/Questa_ATAC_Seq_Canine_FULL/3rd_library"
preproc_dir = "01-Cleaned"
mapping_dir = "02-BWA"
######################
```

```{r setup, echo=FALSE}
knitr::opts_knit$set(root.dir = working_dir)
```

```{r, echo=FALSE}
library(knitr)
library(kableExtra)
library(jsonlite)
library(readr)
library(stringr)
library(edgeR)

process_json <- function(sdir) { 
    json <- fromJSON(paste0(preproc_dir,"/",sdir,"/",sdir,".stats.log"))
    
    infrag = unlist(lapply(names(json), function(x) json[[x]]$totalFragmentsInput))
    outfrag = unlist(lapply(names(json), function(x) json[[x]]$totalFragmentsOutput))
    
    perc = (outfrag/infrag[1])*100
    perc = sprintf("%.02f%%",perc)
    
    stats = matrix(c(rbind(infrag,outfrag,perc)), nrow=1)
    
    logfinal = read_file(paste0(mapping_dir,"/",sdir,"/",sdir,".ALL.flagstat"))
    #lfall = str_match_all(logfinal,"Uniquely mapped reads number \\|\\t(\\d+)\\n.+Uniquely mapped reads \\% \\|\\t(.+\\%)")
    lfall = str_match_all(logfinal,"(\\d+) \\+ 0 mapped \\((.+\\%) :")
    
    lfm = matrix(c(lfall[[1]][,2], lfall[[1]][,3]), nrow=1)
    
    stats = cbind(stats,lfm)
    rownames(stats) = c(sdir)
    
    return(stats)
}

process_counts <- function(sid, colnum) {
  counts = read.table(paste0(mapping_dir,"/",sid,"/",sid,".ALL.counts"),row.names = 1,sep='\t',stringsAsFactors = F,header = F,skip=3)
  counts = counts[,6]
  return(counts)
}
```

```{r, echo=FALSE}
###################
sample_dirs = list.dirs(preproc_dir,full.names = F, recursive = F)

final_stats = t(sapply(sample_dirs, process_json))

json <- fromJSON(paste0(preproc_dir,"/",sample_dirs[1],"/",sample_dirs[1],".stats.log"))
cnames = gsub("_\\d+","",names(json))
cnames = unlist(lapply(cnames, function(x) c(paste(x,"input"), paste(x,"output"), paste(x,"perc"))))

counts_all = sapply(sample_dirs,process_counts)
counts = read.table(paste0(mapping_dir,"/",sample_dirs[1],"/",sample_dirs[1],".ALL.counts"),row.names = 1,sep='\t',stringsAsFactors = F,header=F,skip=3)
rownames(counts_all) = rownames(counts)

rmg = as.matrix(colSums(counts_all), ncol=1)
mr = as.matrix(as.integer(final_stats[,1]), ncol=1)
perc_rmg = as.matrix(sprintf("%.02f%%", (rmg / mr) * 100), ncol=1)

final_stats = cbind(final_stats,rmg,perc_rmg)
colnames(final_stats) = c(cnames,"Mapped Reads","Mapped Perc","Reads Mapped to Genes","Perc Reads Mapped to Genes")

###################
```

## <u>**Preprocessing & Mapping stats**</u>
Preprocessing was done using the [HTStream](https://ibest.github.io/HTStream/) software. The table below shows the number of reads input and output at each step as well as the percentage of reads left (based on the initial input amount). Here are explantions of the various possible steps in your output (Note, your output will not contain every one of these steps):

* hts_AdapterTrimmer: Trims adapters which are sequenced when the fragment insert length is shorter than the read length.
* hts_CutTrim: Trims a fixed number of bases from the 5' and/or 3' end of each read.
* hts_Overlapper: Overlaps paired end reads to produce the original fragment, trims adapters, and can correct sequencing errors.
* hts_QWindowTrim: Uses a sliding window approach to remove the low quality ends of reads.
* hts_Stats: Generates an JSON formatted file containing a set of statistical measures about the input read data.
* hts_NTrimmer: Trims reads to the longest subsequence that contains no Ns.
* hts_PolyATTrim: Trims poly-A and poly-T sequences from the end of reads.
* hts_SeqScreener: A simple sequence screening tool which uses a kmer lookup approach to identify reads from an unwanted source. By default it will look for reads which are likely to have come from PhiX (commonly added to Illumina sequencing runs).
* hts_SuperDeduper: A reference free duplicate read removal tool.

The "Uniquely Mapped Reads", "Uniquely Mapped Perc", "Multi-Mapped Reads", and "Multi-Mapped Perc" columns are all taken from the log files of the aligner. Finally, the "Reads Mapped to Genes", and "Perc Reads Mapped to Genes" columns are calculated from the files of count data and original input numbers.


```{r, echo=FALSE}
numcol = dim(final_stats)[2]
step=6
for (i in seq(1,numcol,step)) {
  if (i+step-1 <= numcol) {
    endcol <- i+step-1
  } else {
    endcol <- numcol
  }
  
  print(kable(final_stats[,i:endcol]) %>% kable_styling(bootstrap_options = c("striped", "hover")))
}
```
## **<u>MDS Plot</u>**

Multidimensional scaling (MDS) is a means of visualizing the level of similarity of individual cases of a dataset. MDS is used to translate information about the pairwise 'distances' among a set of n objects or individuals into a configuration of n points mapped onto a two-dimensional space.

```{r, echo=FALSE}
countdge = DGEList(counts_all)
countdge = calcNormFactors(countdge)
plotMDS(countdge, main="MDS Plot")
```

